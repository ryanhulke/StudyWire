import sys
import time
from pprint import pprint

import httpx

BASE_URL = "http://127.0.0.1:8000/api"


def print_header(title: str) -> None:
    print("\n" + "=" * 80)
    print(title)
    print("=" * 80)


def main() -> None:
    client = httpx.Client(timeout=30.0)

    # -------------------------------------------------------------------------
    # 1. Health check
    # -------------------------------------------------------------------------
    print_header("1. Health check")
    try:
        resp = client.get(f"{BASE_URL}/health")
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Health check failed: {e}")
        sys.exit(1)

    print("Health response:")
    pprint(resp.json())

    # -------------------------------------------------------------------------
    # 2. Reindex notes
    # -------------------------------------------------------------------------
    print_header("2. Reindex notes")
    try:
        resp = client.post(f"{BASE_URL}/reindex")
        resp.raise_for_status()
    except httpx.HTTPStatusError as e:
        print(f"[ERROR] Reindex failed with status {e.response.status_code}")
        print("Body:", e.response.text)
        # For smoke test, if reindex fails (e.g., NOTES_ROOT missing), abort
        sys.exit(1)
    except httpx.HTTPError as e:
        print(f"[ERROR] Reindex HTTP error: {e}")
        sys.exit(1)

    print("Reindex response:")
    pprint(resp.json())

    # -------------------------------------------------------------------------
    # 3. List sources & chunks
    # -------------------------------------------------------------------------
    print_header("3. List sources & chunks")
    try:
        resp = client.get(f"{BASE_URL}/sources")
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Listing sources failed: {e}")
        sys.exit(1)

    sources = resp.json()
    print(f"Found {len(sources)} sources")
    if sources:
        first_source = sources[0]
        print("First source:")
        pprint(first_source)

        source_id = first_source["id"]
        try:
            resp_chunks = client.get(f"{BASE_URL}/sources/{source_id}/chunks")
            resp_chunks.raise_for_status()
        except httpx.HTTPError as e:
            print(f"[ERROR] Listing chunks for source {source_id} failed: {e}")
            sys.exit(1)

        chunks = resp_chunks.json()
        print(f"Source {source_id} has {len(chunks)} chunks")
        if chunks:
            print("First chunk (truncated text):")
            first_chunk = dict(chunks[0])
            text = first_chunk.get("text", "")
            first_chunk["text"] = text[:200] + ("..." if len(text) > 200 else "")
            pprint(first_chunk)
    else:
        print("No sources found. Reindex may have scanned an empty Notes folder.")

    # -------------------------------------------------------------------------
    # 4. Create a test deck
    # -------------------------------------------------------------------------
    print_header("4. Create a test deck")
    deck_name = f"SmokeTest-{int(time.time())}"
    deck_payload = {"name": deck_name, "description": "Smoke test deck"}
    try:
        resp = client.post(f"{BASE_URL}/decks", json=deck_payload)
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Creating deck failed: {e}")
        sys.exit(1)

    deck = resp.json()
    pprint(deck)
    deck_id = deck["id"]

    # -------------------------------------------------------------------------
    # 5. Create a test card and list cards
    # -------------------------------------------------------------------------
    print_header("5. Create a test card and list cards")

    card_payload = {
        "deck_id": deck_id,
        "front": "What is the purpose of this card?",
        "back": "This is a smoke-test card generated by smoke_test.py.",
        "card_type": "basic",
        "tags": ["smoke_test"],
        "source_id": None,
        "source_chunk_id": None,
    }

    try:
        resp = client.post(f"{BASE_URL}/cards", json=card_payload)
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Creating card failed: {e}")
        sys.exit(1)

    created_card = resp.json()
    print("Created card:")
    pprint(created_card)
    card_id = created_card["id"]

    # List cards in this deck
    try:
        resp = client.get(f"{BASE_URL}/cards", params={"deck_id": deck_id})
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Listing cards failed: {e}")
        sys.exit(1)

    cards = resp.json()
    print(f"Deck {deck_id} has {len(cards)} cards")
    if cards:
        print("First card in deck:")
        pprint(cards[0])

    # -------------------------------------------------------------------------
    # 6. Review flow: summary -> next -> answer -> summary
    # -------------------------------------------------------------------------
    print_header("6. Review flow")

    # Summary before
    try:
        resp = client.get(f"{BASE_URL}/review/summary")
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Getting review summary failed: {e}")
        sys.exit(1)

    summary_before = resp.json()
    print("Review summary before answering:")
    pprint(summary_before)

    # Next card
    try:
        resp = client.get(f"{BASE_URL}/review/next")
        if resp.status_code == 404:
            print("No due cards (unexpected if new card exists, but not fatal).")
            next_card = None
        else:
            resp.raise_for_status()
            next_card = resp.json()
    except httpx.HTTPError as e:
        print(f"[ERROR] Getting next review card failed: {e}")
        sys.exit(1)

    if next_card:
        print("Next review card:")
        pprint(next_card)

        # Answer with rating=3 (Good)
        answer_payload = {
            "card_id": next_card["card_id"],
            "rating": 3,
            "duration_ms": 1500,
        }
        try:
            resp = client.post(
                f"{BASE_URL}/review/answer", json=answer_payload
            )
            resp.raise_for_status()
        except httpx.HTTPError as e:
            print(f"[ERROR] Answering review failed: {e}")
            sys.exit(1)

        print("Review answer response:")
        pprint(resp.json())
    else:
        print("Skipping answer step as no due card was returned.")

    # Summary after
    try:
        resp = client.get(f"{BASE_URL}/review/summary")
        resp.raise_for_status()
    except httpx.HTTPError as e:
        print(f"[ERROR] Getting review summary (after) failed: {e}")
        sys.exit(1)

    summary_after = resp.json()
    print("Review summary after answering:")
    pprint(summary_after)

    # -------------------------------------------------------------------------
    # 7. LLM flashcard generation (if sources + chunks exist)
    # -------------------------------------------------------------------------
    print_header("7. LLM flashcard generation")

    if not sources:
        print("Skipping generate_cards: no sources available.")
    else:
        source_id = sources[0]["id"]
        # Reuse the chunks we fetched earlier, or fetch again if needed
        try:
            resp_chunks = client.get(f"{BASE_URL}/sources/{source_id}/chunks")
            resp_chunks.raise_for_status()
        except httpx.HTTPError as e:
            print(f"[ERROR] Fetching chunks for generate_cards failed: {e}")
            sys.exit(1)

        chunks = resp_chunks.json()
        if not chunks:
            print("Skipping generate_cards: selected source has no chunks.")
        else:
            # Use up to first 3 chunks to limit prompt size
            chunk_ids = [ch["id"] for ch in chunks[:3]]
            gen_payload = {
                "source_id": source_id,
                "chunk_ids": chunk_ids,
                "num_cards": 3,
                "temperature": 0.7,
            }
            try:
                resp = client.post(
                    f"{BASE_URL}/generate_cards", json=gen_payload
                )
                resp.raise_for_status()
            except httpx.HTTPStatusError as e:
                print(
                    "[WARN] generate_cards failed with HTTP status "
                    f"{e.response.status_code}"
                )
                print("Body:", e.response.text)
            except httpx.HTTPError as e:
                print(f"[WARN] generate_cards HTTP error: {e}")
            else:
                gen_result = resp.json()
                print("Generated cards from LLM:")
                pprint(gen_result)

    print_header("Smoke test completed")


if __name__ == "__main__":
    main()
